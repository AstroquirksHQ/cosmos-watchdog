[uwsgi]
strict = true ; force full-compliance with uwsgi option-set
master = true ; use a master process for running uwsgi interpreters
enable-threads = true ; enable threads in python interpreter
vacuum = true ; close and clean socket files upon process killing
single-interpreter = true ; use a single interpreter since we are mono-application
die-on-term=true
need-app = true
so-keepalive = true
log-master=true

logger = default stdio
logger = applogger stdio
log-route = applogger {
log-route = default ^((?!\{).)*$
log-encoder = json:default {"timestamp":"${strftime:%%Y-%%m-%%d %%H:%%M:%%S}", "timestamp_iso":"${strftime:%%Y-%%m-%%dT%%H:%%M:%%SZ}", "timestamp_micros":"${micros}", "source":"uwsgi", "message":"${msg}"}
log-encoder = format:applogger ${msg}
log-encoder = nl
logger-req = stdio
log-format = "address":"%(addr)", "host":"%(host)", "method":"%(method)", "uri":"%(uri)", "protocol":"%(proto)", "resp_size":%(size), "req_body_size":%(cl), "resp_status":%(status), "resp_time":%(secs)
log-req-encoder = format {"timestamp":"${strftime:%%Y-%%m-%%d %%H:%%M:%%S}", "timestamp_iso":"${strftime:%%Y-%%m-%%dT%%H:%%M:%%SZ}", "timestamp_micros":"${micros}", "source":"uwsgi-req", ${msg}}
log-req-encoder = nl

lazy-apps = true ; First fork, then load the app, which ensures connections are not badly shared between processes

post-buffering = true ; Enable buffering of POST data so unread data does not block the server
buffer-size = 65535 ; Set the max size of a request (request-body excluded), this generally maps to the size of request headers

module = wsgi
callable = app
http-socket = $(HOST):5000
http-connect-timeout = 10
harakiri = 10

processes = 4      ; Maximum number of workers allowed
cheaper-algo = busyness
cheaper = 2        ; Minimum number of workers allowed
cheaper-initial = 2 ; Workers created at startup
cheaper-overload = 60                              ; Length of a cycle in seconds
cheaper-step = 1                                   ; How many workers to spawn at a time
cheaper-busyness-multiplier = 5                    ; How many cycles to wait before killing workers
cheaper-busyness-max = 70                          ; Above this threshold, spawn new workers

memory-report = true
; soft limit will prevent cheaper from spawning new workers
; soft limit is 600MB, or 150MB per process
cheaper-rss-limit-soft = %(157286400 * 4)
; hard limit will force cheaper to cheap single worker
; hard limit is 720MB, or 180MB per process
cheaper-rss-limit-hard = %(188743680 * 4)
; Reload a worker if its physical unshared memory is higher than the specified value (in megabytes).
reload-on-rss = 256
; Reload workers after this many seconds.
max-worker-lifetime = 3600
; Delta to prevent all workers from reloading at the same time
max-worker-lifetime-delta = 60
